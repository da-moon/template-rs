[config]
default_to_workspace = true
skip_core_tasks = true

[env]
# Enable workspace makefile extension
CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true

# Common arguments - can be overridden
MESSAGE_FORMAT = { value = "--message-format=short", condition = { env_not_set = ["MESSAGE_FORMAT"] } }
ALL_FEATURES = { value = "--all-features", condition = { env_not_set = ["ALL_FEATURES"] } }
ALL_TARGETS = { value = "--all-targets", condition = { env_not_set = ["ALL_TARGETS"] } }
WORKSPACE_FLAG = { value = "--workspace", condition = { env_not_set = ["WORKSPACE_FLAG"] } }

# Feature handling
FEATURES = { value = "", condition = { env_not_set = ["FEATURES"] } }

# Build configuration
RELEASE = { value = "0", condition = { env_not_set = ["RELEASE"] } }
STRICT = { value = "0", condition = { env_not_set = ["STRICT"] } }

# Clippy configurations - single source of truth
CLIPPY_BASE_ARGS = "-D warnings"
STRICT_CLIPPY_DENY = "--deny warnings --deny clippy::pedantic --deny clippy::nursery"
STRICT_CLIPPY_ALLOW = "--allow clippy::wildcard_imports --allow clippy::used_underscore_binding --allow clippy::missing_docs_in_private_items --allow clippy::missing_panics_doc --allow clippy::missing_errors_doc --allow clippy::missing_safety_doc --allow clippy::doc_markdown"

# Paths
BIN_DIR = { value = "target/debug", condition = { env_not_set = ["BIN_DIR"] } }
DIST_DIR = { value = "dist", condition = { env_not_set = ["DIST_DIR"] } }

#  ╭──────────────────────────────────────────────────────────╮
#  │                    Initialization                        │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.init]
extend = "Makefile.toml"

#  ╭──────────────────────────────────────────────────────────╮
#  │                  Target Preparation                      │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.prepare_targets]
extend = "Makefile.toml"

#  ╭──────────────────────────────────────────────────────────╮
#  │                 Workspace-Wide Tasks                     │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.clean]
description = "Clean all workspace members"
category = "Build"
command = "cargo"
args = ["clean", "${WORKSPACE_FLAG}"]

[tasks.doc]
description = "Generate documentation for all workspace members"
category = "Documentation"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
exec --fail-on-error cargo doc ${WORKSPACE_FLAG} ${feature_args} --no-deps
'''

[tasks.build_all]
description = "Build all workspace members for host target"
category = "Build"
dependencies = ["init"]
script = '''
#!@duckscript
cargo_args = get_env CARGO_BUILD_ARGS
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo build ${WORKSPACE_FLAG} ${cargo_args} ${feature_args} ${message_format}
'''

[tasks.test_all]
description = "Run tests for all workspace members on host target"
category = "Test"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo test ${WORKSPACE_FLAG} ${feature_args} ${message_format}
'''

[tasks.check_all]
description = "Run cargo check on all workspace members for host target"
category = "Build"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo check ${WORKSPACE_FLAG} ${feature_args} ${message_format}
'''

[tasks.clippy_all]
description = "Run clippy on all workspace members for host target"
category = "Build"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
clippy_args = get_env CLIPPY_ARGS
all_targets = get_env ALL_TARGETS
exec --fail-on-error cargo clippy ${WORKSPACE_FLAG} ${feature_args} ${all_targets} ${message_format} -- ${clippy_args}
'''

[tasks.format_all]
description = "Check formatting for all workspace members"
category = "Development"
command = "cargo"
args = ["fmt", "${WORKSPACE_FLAG}", "--", "--check"]

[tasks.format_fix_all]
description = "Fix formatting for all workspace members"
category = "Development"
command = "cargo"
args = ["fmt", "${WORKSPACE_FLAG}"]

[tasks.fix_all]
description = "Run cargo fix on all workspace members"
category = "Development"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo fix ${WORKSPACE_FLAG} ${feature_args} ${message_format} --allow-dirty
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │            Workspace Member×Target Matrix                │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.build_all_members_targets]
description = "Build all workspace members for all specified targets"
category = "Build"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

members = get_env WORKSPACE_MEMBERS
member_list = split ${members} " "
targets = get_env TARGETS
target_list = split ${targets} " "
cargo_args = get_env CARGO_BUILD_ARGS
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT

for member in ${member_list}
    member = trim ${member}
    if not is_empty ${member}
        echo "=== Building member: ${member} ==="
        for target in ${target_list}
            target = trim ${target}
            if not is_empty ${target}
                echo "  Building for target: ${target}"
                if equals ${member} "."
                    exec --fail-on-error cargo build --target ${target} ${cargo_args} ${feature_args} ${message_format}
                else
                    exec --fail-on-error cargo build -p ${member} --target ${target} ${cargo_args} ${feature_args} ${message_format}
                end
            end
        end
    end
end
'''

[tasks.check_all_members_targets]
description = "Run cargo check on all workspace members for all specified targets"
category = "Build"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

members = get_env WORKSPACE_MEMBERS
member_list = split ${members} " "
targets = get_env TARGETS
target_list = split ${targets} " "
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT

for member in ${member_list}
    member = trim ${member}
    if not is_empty ${member}
        echo "=== Checking member: ${member} ==="
        for target in ${target_list}
            target = trim ${target}
            if not is_empty ${target}
                echo "  Checking target: ${target}"
                if equals ${member} "."
                    exec --fail-on-error cargo check --target ${target} ${feature_args} ${message_format}
                else
                    exec --fail-on-error cargo check -p ${member} --target ${target} ${feature_args} ${message_format}
                end
            end
        end
    end
end
'''

[tasks.clippy_all_members_targets]
description = "Run clippy on all workspace members for all specified targets"
category = "Build"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

members = get_env WORKSPACE_MEMBERS
member_list = split ${members} " "
targets = get_env TARGETS
target_list = split ${targets} " "
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
clippy_args = get_env CLIPPY_ARGS
all_targets = get_env ALL_TARGETS

for member in ${member_list}
    member = trim ${member}
    if not is_empty ${member}
        echo "=== Running clippy for member: ${member} ==="
        for target in ${target_list}
            target = trim ${target}
            if not is_empty ${target}
                echo "  Clippy for target: ${target}"
                if equals ${member} "."
                    exec --fail-on-error cargo clippy --target ${target} ${feature_args} ${all_targets} ${message_format} -- ${clippy_args}
                else
                    exec --fail-on-error cargo clippy -p ${member} --target ${target} ${feature_args} ${all_targets} ${message_format} -- ${clippy_args}
                end
            end
        end
    end
end
'''

[tasks.test_all_members_targets]
description = "Run tests for all workspace members on all specified targets (skips if no runner)"
category = "Test"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

members = get_env WORKSPACE_MEMBERS
member_list = split ${members} " "
targets = get_env TARGETS
target_list = split ${targets} " "
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
host_triple = get_env HOST_TRIPLE

for member in ${member_list}
    member = trim ${member}
    if not is_empty ${member}
        echo "=== Testing member: ${member} ==="
        for target in ${target_list}
            target = trim ${target}
            if not is_empty ${target}
                # Check if we need a runner for cross-compilation
                needs_runner = not equals ${target} ${host_triple}
                
                if ${needs_runner}
                    # Check if runner is configured
                    runner_env = concat "CARGO_TARGET_" ${target}
                    runner_env = replace ${runner_env} "-" "_"
                    runner_env = to_uppercase ${runner_env}
                    runner_env = concat ${runner_env} "_RUNNER"
                    
                    runner = get_env ${runner_env}
                    if is_empty ${runner}
                        echo "  Skipping tests for ${target}: no runner configured (set ${runner_env})"
                    else
                        echo "  Testing target ${target} with runner: ${runner}"
                        if equals ${member} "."
                            exec --fail-on-error cargo test --target ${target} ${feature_args} ${message_format}
                        else
                            exec --fail-on-error cargo test -p ${member} --target ${target} ${feature_args} ${message_format}
                        end
                    end
                else
                    echo "  Testing target: ${target}"
                    if equals ${member} "."
                        exec --fail-on-error cargo test --target ${target} ${feature_args} ${message_format}
                    else
                        exec --fail-on-error cargo test -p ${member} --target ${target} ${feature_args} ${message_format}
                    end
                end
            end
        end
    end
end
'''

[tasks.package_all_members_targets]
description = "Package all workspace member binaries for all targets"
category = "Build"
dependencies = ["init", "build_all_members_targets"]
script = '''
#!@duckscript

members = get_env WORKSPACE_MEMBERS
member_list = split ${members} " "
targets = get_env TARGETS
target_list = split ${targets} " "
dist_dir = get_env DIST_DIR

# Get workspace metadata
output = exec --get-exit-code cargo metadata --no-deps --format-version 1
if not equals ${output.code} 0
    trigger_error "Failed to get cargo metadata"
end

for member in ${member_list}
    member = trim ${member}
    if not is_empty ${member}
        echo "=== Packaging member: ${member} ==="
        
        # Get member metadata
        member_path = ${member}
        if equals ${member} "."
            member_path = ""
        end
        
        # Check if member has a binary
        member_toml = concat ${member_path} "/Cargo.toml"
        if equals ${member} "."
            member_toml = "Cargo.toml"
        end
        
        if is_path_exists ${member_toml}
            cargo_content = readfile ${member_toml}
            
            # Check for [[bin]] or default src/main.rs
            has_bin = contains ${cargo_content} "[[bin]]"
            main_rs = concat ${member_path} "/src/main.rs"
            if equals ${member} "."
                main_rs = "src/main.rs"
            end
            
            if not ${has_bin}
                has_bin = is_path_exists ${main_rs}
            end
            
            if ${has_bin}
                # Extract crate name and version
                crate_name = ""
                crate_version = ""
                
                # Basic TOML parsing for name and version (only from [package] section)
                lines = split ${cargo_content} \n
                in_package_section = ""
                for line in ${lines}
                    trimmed_line = trim ${line}
                    
                    # Check if we're entering/leaving a section
                    if starts_with ${trimmed_line} "["
                        if equals ${trimmed_line} "[package]"
                            in_package_section = "true"
                        else
                            in_package_section = ""
                        end
                    elif not is_empty ${in_package_section}
                        # Only parse name and version within [package] section
                        # Remove all whitespace around = for consistent parsing
                        normalized_line = replace ${trimmed_line} " " ""
                        
                        if starts_with ${normalized_line} "name="
                            # Handle both quoted and unquoted values
                            parts = split ${trimmed_line} "\""
                            if greater_than ${parts.length} 1
                                crate_name = array_get ${parts} 1
                            else
                                # Try splitting by = for unquoted values
                                parts = split ${trimmed_line} "="
                                if greater_than ${parts.length} 1
                                    value = array_get ${parts} 1
                                    # Trim whitespace and quotes
                                    crate_name = trim ${value}
                                    crate_name = replace ${crate_name} "\"" ""
                                end
                            end
                        elif starts_with ${normalized_line} "version="
                            # Handle both quoted and unquoted values
                            parts = split ${trimmed_line} "\""
                            if greater_than ${parts.length} 1
                                crate_version = array_get ${parts} 1
                            else
                                # Try splitting by = for unquoted values
                                parts = split ${trimmed_line} "="
                                if greater_than ${parts.length} 1
                                    value = array_get ${parts} 1
                                    # Trim whitespace and quotes
                                    crate_version = trim ${value}
                                    crate_version = replace ${crate_version} "\"" ""
                                end
                            end
                        end
                    end
                end
                
                # Look for binary name
                binary_names_str = ""
                in_bin = ""
                for line in ${lines}
                    t = trim ${line}
                    if starts_with ${t} "[[bin]]"
                        in_bin = "1"
                    elif starts_with ${t} "[["
                        # Reset in_bin when encountering any other section
                        in_bin = ""
                    elif starts_with ${t} "["
                        # Reset in_bin when encountering any section
                        in_bin = ""
                    elif not is_empty ${in_bin}
                        # Check for exact "name = " pattern to avoid matching namespace, etc.
                        if starts_with ${t} "name = "
                            parts = split ${t} "\""
                            if greater_than ${parts.length} 1
                                bn = array_get ${parts} 1
                                if not is_empty ${bn}
                                    binary_names_str = concat ${binary_names_str} " " ${bn}
                                end
                            end
                        end
                    end
                end
                
                # Default binary name to crate name
                if is_empty ${binary_names_str}
                    binary_names_str = ${crate_name}
                end
                binary_names_str = trim ${binary_names_str}
                bin_list = split ${binary_names_str} " "
                
                if not is_empty ${crate_name}
                    for target in ${target_list}
                        target = trim ${target}
                        if not is_empty ${target}
                            # Determine target directory
                            target_dir = concat "target/" ${target}
                            release = get_env RELEASE
                            if equals ${release} "1"
                                target_dir = concat ${target_dir} "/release"
                            else
                                target_dir = concat ${target_dir} "/debug"
                            end
                            
                            for binary_name in ${bin_list}
                                binary_name = trim ${binary_name}
                                if not is_empty ${binary_name}
                                    # Source binary path
                                    src_binary = concat ${target_dir} "/" ${binary_name}
                                    
                                    # Handle Windows suffix
                                    if contains ${target} "windows"
                                        if not ends_with ${src_binary} ".exe"
                                            src_binary = concat ${src_binary} ".exe"
                                        end
                                    end
                                    
                                    # Check if binary exists
                                    if is_path_exists ${src_binary}
                                        # Create distribution directory
                                        dist_target_dir = concat ${dist_dir} "/" ${target}
                                        mkdir ${dist_target_dir}
                                        
                                        # Destination filename includes binary name
                                        dest_name = concat ${binary_name} "-" ${crate_version} "-" ${target}
                                        if contains ${target} "windows"
                                            dest_name = concat ${dest_name} ".exe"
                                        end
                                        
                                        dest_path = concat ${dist_target_dir} "/" ${dest_name}
                                        
                                        echo "Copying ${src_binary} -> ${dest_path}"
                                        cp ${src_binary} ${dest_path}
                                    else
                                        echo "Warning: Binary not found at ${src_binary}"
                                    end
                                end
                            end
                        end
                    end
                end
            else
                echo "  Skipping ${member}: no binary target found"
            end
        end
    end
end
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │              Per-Member Tasks (Host Only)                │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.build_member]
description = "Build a specific workspace member (use with MEMBER=<name>)"
category = "Build"
dependencies = ["init"]
condition = { env_set = ["MEMBER"] }
script = '''
#!@duckscript
member = get_env MEMBER
cargo_args = get_env CARGO_BUILD_ARGS
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
echo "Building member: ${member}"
exec --fail-on-error cargo build -p ${member} ${cargo_args} ${feature_args} ${message_format}
'''

[tasks.test_member]
description = "Test a specific workspace member (use with MEMBER=<name>)"
category = "Test"
dependencies = ["init"]
condition = { env_set = ["MEMBER"] }
script = '''
#!@duckscript
member = get_env MEMBER
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
echo "Testing member: ${member}"
exec --fail-on-error cargo test -p ${member} ${feature_args} ${message_format}
'''

[tasks.check_member]
description = "Check a specific workspace member (use with MEMBER=<name>)"
category = "Build"
dependencies = ["init"]
condition = { env_set = ["MEMBER"] }
script = '''
#!@duckscript
member = get_env MEMBER
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
echo "Checking member: ${member}"
exec --fail-on-error cargo check -p ${member} ${feature_args} ${message_format}
'''

[tasks.clippy_member]
description = "Run clippy on a specific workspace member (use with MEMBER=<name>)"
category = "Build"
dependencies = ["init"]
condition = { env_set = ["MEMBER"] }
script = '''
#!@duckscript
member = get_env MEMBER
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
clippy_args = get_env CLIPPY_ARGS
all_targets = get_env ALL_TARGETS
echo "Running clippy on member: ${member}"
exec --fail-on-error cargo clippy -p ${member} ${feature_args} ${all_targets} ${message_format} -- ${clippy_args}
'''

[tasks.run_member]
description = "Run a specific workspace member binary (use with MEMBER=<name>)"
category = "Development"
dependencies = ["init"]
condition = { env_set = ["MEMBER"] }
script = '''
#!@duckscript
member = get_env MEMBER
cargo_args = get_env CARGO_BUILD_ARGS
feature_args = get_env FEATURE_ARGS
echo "Running member: ${member}"
exec --fail-on-error cargo run -p ${member} ${cargo_args} ${feature_args}
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │                  Validation Sequences                    │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.validate_all]
description = "Run validation sequence for all workspace members: format, build, test, clippy"
category = "CI"
dependencies = ["format_all", "build_all", "test_all", "clippy_all"]

[tasks.validate_all_targets]
description = "Run validation for all members and targets"
category = "CI"
dependencies = ["format_all", "build_all_members_targets", "test_all_members_targets", "clippy_all_members_targets"]

[tasks.validate_all_strict]
description = "Run validation for all members with strict clippy"
category = "CI"
env = { "STRICT" = "1" }
dependencies = ["format_all", "build_all", "test_all", "clippy_all"]

#  ╭──────────────────────────────────────────────────────────╮
#  │                    Utility Tasks                         │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.list_members]
description = "List all workspace members"
category = "Tools"
dependencies = ["init"]
script = '''
#!@duckscript
members = get_env WORKSPACE_MEMBERS
member_list = split ${members} " "
echo "Workspace members:"
for member in ${member_list}
    member = trim ${member}
    if not is_empty ${member}
        echo "  - ${member}"
    end
end
'''

[tasks.list_targets]
description = "List all configured targets"
category = "Tools"
dependencies = ["init"]
script = '''
#!@duckscript
targets = get_env TARGETS
target_list = split ${targets} " "
echo "Configured targets:"
for target in ${target_list}
    target = trim ${target}
    if not is_empty ${target}
        echo "  - ${target}"
    end
end
'''
