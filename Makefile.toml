[config]
default_to_workspace = false
skip_core_tasks = true

[env]
# Common arguments used across multiple tasks
MESSAGE_FORMAT = "--message-format=short"
ALL_FEATURES = "--all-features"
ALL_TARGETS = "--all-targets"
WORKSPACE_FLAG = "--workspace"

# Clippy configurations
CLIPPY_BASE_ARGS = "-D warnings"
STRICT_CLIPPY_DENY = "--deny warnings --deny clippy::pedantic --deny clippy::nursery"
STRICT_CLIPPY_ALLOW = "--allow clippy::wildcard_imports --allow clippy::used_underscore_binding --allow clippy::missing_docs_in_private_items --allow clippy::missing_panics_doc --allow clippy::missing_errors_doc --allow clippy::missing_safety_doc --allow clippy::doc_markdown"

#  ╭──────────────────────────────────────────────────────────╮
#  │                    Root Tasks                            │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.build]
description = "Build with short messages"
command = "cargo"
args = ["build", "${MESSAGE_FORMAT}"]

[tasks.test]
description = "Run unit tests"
command = "cargo"
args = ["test", "${MESSAGE_FORMAT}"]

[tasks.check]
description = "Run cargo check"
command = "cargo"
args = ["check", "${MESSAGE_FORMAT}"]

[tasks.clippy]
description = "Run clippy checks"
script = [
'''
#!@duckscript
exec --fail-on-error cargo clippy ${MESSAGE_FORMAT} ${ALL_TARGETS} ${ALL_FEATURES} -- ${CLIPPY_BASE_ARGS}
'''
]

[tasks.strict-clippy]
description = "Run clippy checks in pedantic mode"
script = [
'''
#!@duckscript
exec --fail-on-error cargo clippy ${ALL_FEATURES} ${MESSAGE_FORMAT} -- ${STRICT_CLIPPY_DENY} ${STRICT_CLIPPY_ALLOW}
'''
]

[tasks.format]
description = "Fix code formatting"
command = "cargo"
args = ["fmt"]

[tasks.fix]
description = "Run cargo fix"
command = "cargo"
args = ["fix", "${MESSAGE_FORMAT}", "--allow-dirty", "--lib"]

[tasks.fix_edition]
description = "Run cargo fix with edition migration"
command = "cargo"
args = ["fix", "${MESSAGE_FORMAT}", "--allow-dirty", "--lib", "--edition"]

[tasks.fix_clippy]
description = "Run cargo fix with clippy suggestions"
script = [
'''
#!@duckscript
exec --fail-on-error cargo clippy ${MESSAGE_FORMAT} ${ALL_TARGETS} ${ALL_FEATURES} --fix --allow-dirty -- -D warnings
'''
]

#  ╭──────────────────────────────────────────────────────────╮
#  │                  Validation Sequences                    │
#  ╰──────────────────────────────────────────────────────────╯
[tasks.validate_initial]
description = "Run full validation sequence: build, test, format, fix, check, clippy"
dependencies = ["build", "test", "format", "fix", "check", "clippy"]

[tasks.validate]
description = "Run full validation sequence: build, test, fix, format, check, clippy"
dependencies = ["build", "test", "format","fix" , "check", "clippy"]

[tasks.validate_strict]
description = "Run full validation sequence with strict clippy"
dependencies = ["build", "test", "format","fix", "check", "strict-clippy"]

[tasks.package_targets]
description = "Package built binary targets into dist/ with correct crate name and version"
script = [
'''
#!@duckscript

# Ensure jq is available
jq_exists = exec_output bash -c "command -v jq >/dev/null 2>&1; echo $?"
assert_eq ${jq_exists.stdout} "0" "jq is required but not found. Please install jq."

# Determine root Cargo.toml path
locate = exec_output cargo locate-project --message-format plain
assert ${locate.exit_code} "Failed to locate Cargo.toml"
root_manifest = trim ${locate.stdout}

# Fetch cargo metadata for the current project
meta = exec_output cargo metadata --format-version 1 --no-deps --manifest-path ${root_manifest}
assert ${meta.exit_code} "Failed to retrieve cargo metadata"
meta_json = set ${meta.stdout}

# Write metadata to a temporary file for jq processing
tmpfile = tempfile
writefile ${tmpfile} ${meta_json}

# Extract crate name and version for the current manifest path
name_out = exec_output bash -c "jq -r --arg mp '${root_manifest}' '.packages[] | select(.manifest_path == $mp) | .name' ${tmpfile}"
assert ${name_out.exit_code} "Failed to parse crate name from cargo metadata"
crate_name = trim ${name_out.stdout}

ver_out = exec_output bash -c "jq -r --arg mp '${root_manifest}' '.packages[] | select(.manifest_path == $mp) | .version' ${tmpfile}"
assert ${ver_out.exit_code} "Failed to parse crate version from cargo metadata"
crate_version = trim ${ver_out.stdout}

# Get list of binary targets for the current crate
bins_out = exec_output bash -c "jq -r --arg mp '${root_manifest}' '.packages[] | select(.manifest_path == $mp) | .targets[] | select(.kind[] == \"bin\") | .name' ${tmpfile}"
assert ${bins_out.exit_code} "Failed to parse binary targets from cargo metadata"

# Prepare dist directory
dist_dir = set dist
mkdir ${dist_dir}

# Package each binary target from target/release
bins = split ${bins_out.stdout} "\n"
for bin_name in ${bins}
    skip = is_empty ${bin_name}
    if not ${skip}
        src_path = set target/release/${bin_name}
        exists = is_file ${src_path}
        if ${exists}
            # If multiple binaries, include bin name in artifact; if single, still include for consistency
            artifact = set ${dist_dir}/${crate_name}-v${crate_version}-${bin_name}
            cp ${src_path} ${artifact}
            chmod +x ${artifact}
            echo Packaged ${artifact}
        else
            echo Warning: built binary not found at ${src_path}. Did you run a release build?
        end
    end
end

# Clean up
rm ${tmpfile}
'''
]


