[config]
default_to_workspace = false
skip_core_tasks = true

[env]
# Enable workspace makefile extension
CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true

# Common arguments - can be overridden
MESSAGE_FORMAT = { value = "--message-format=short", condition = { env_not_set = ["MESSAGE_FORMAT"] } }
ALL_FEATURES = { value = "--all-features", condition = { env_not_set = ["ALL_FEATURES"] } }
ALL_TARGETS = { value = "--all-targets", condition = { env_not_set = ["ALL_TARGETS"] } }
WORKSPACE_FLAG = { value = "--workspace", condition = { env_not_set = ["WORKSPACE_FLAG"] } }

# Feature handling
FEATURES = { value = "", condition = { env_not_set = ["FEATURES"] } }

# Build configuration
RELEASE = { value = "0", condition = { env_not_set = ["RELEASE"] } }
STRICT = { value = "0", condition = { env_not_set = ["STRICT"] } }

# Clippy configurations - single source of truth
CLIPPY_BASE_ARGS = "-D warnings"
STRICT_CLIPPY_DENY = "--deny warnings --deny clippy::pedantic --deny clippy::nursery"
STRICT_CLIPPY_ALLOW = "--allow clippy::wildcard_imports --allow clippy::used_underscore_binding --allow clippy::missing_docs_in_private_items --allow clippy::missing_panics_doc --allow clippy::missing_errors_doc --allow clippy::missing_safety_doc --allow clippy::doc_markdown"

# Paths
BIN_DIR = { value = "target/debug", condition = { env_not_set = ["BIN_DIR"] } }
DIST_DIR = { value = "dist", condition = { env_not_set = ["DIST_DIR"] } }

#  ╭──────────────────────────────────────────────────────────╮
#  │                    Initialization                        │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.init]
description = "Initialize environment variables and normalize paths"
category = "Build"
script = '''
#!@duckscript

# Get host triple from rustc
output = exec --get-exit-code rustc -vV
if not equals ${output.code} 0
    trigger_error "Failed to get rustc version info"
end

host_triple = ""
lines = split ${output.stdout} \n
for line in ${lines}
    if starts_with ${line} "host:"
        parts = split ${line} " "
        host_triple = array_get ${parts} 1
        host_triple = trim ${host_triple}
    end
end

if is_empty ${host_triple}
    trigger_error "Failed to determine host triple"
end

set_env HOST_TRIPLE ${host_triple}
echo "Host triple: ${host_triple}"

# Set TARGETS to host if not specified
targets = get_env TARGETS
if is_empty ${targets}
    set_env TARGETS ${host_triple}
    echo "TARGETS not set, defaulting to host: ${host_triple}"
else
    echo "TARGETS: ${targets}"
end

# Set executable suffix based on target
exe_suffix = ""
if contains ${host_triple} "windows"
    exe_suffix = ".exe"
end
set_env EXE_SUFFIX ${exe_suffix}

# Update paths based on release mode
release = get_env RELEASE
if equals ${release} "1"
    set_env BIN_DIR "target/release"
    set_env CARGO_BUILD_ARGS "--release"
else
    set_env BIN_DIR "target/debug"
    set_env CARGO_BUILD_ARGS ""
end

# Discover workspace members
members_env = get_env CARGO_MAKE_CRATE_WORKSPACE_MEMBERS
if not is_empty ${members_env}
    # Transform semicolon/comma delimited to space delimited
    members = replace ${members_env} ";" " "
    members = replace ${members} "," " "
    set_env WORKSPACE_MEMBERS ${members}
    echo "Workspace members from env: ${members}"
else
    # Fallback: discover via filesystem
    echo "Discovering workspace members via filesystem..."
    member_list = array
    
    # Look for Cargo.toml files
    handle = glob_array **/Cargo.toml
    for path in ${handle}
        # Skip root Cargo.toml
        if not equals ${path} "Cargo.toml"
            # Extract directory
            dir = dirname ${path}
            array_push ${member_list} ${dir}
        end
    end
    
    # Convert array to space-delimited string
    members = array_join ${member_list} " "
    if is_empty ${members}
        # Single crate project
        members = "."
    end
    set_env WORKSPACE_MEMBERS ${members}
    echo "Discovered members: ${members}"
end

# Set up feature args
features = get_env FEATURES
all_features = get_env ALL_FEATURES
feature_args = ""

if not is_empty ${features}
    feature_args = concat "--features " ${features}
elif not is_empty ${all_features}
    feature_args = ${all_features}
end
set_env FEATURE_ARGS ${feature_args}

# Set up clippy args based on STRICT
strict = get_env STRICT
if equals ${strict} "1"
    set_env CLIPPY_ARGS "${STRICT_CLIPPY_DENY} ${STRICT_CLIPPY_ALLOW}"
else
    set_env CLIPPY_ARGS "${CLIPPY_BASE_ARGS}"
end
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │                  Target Preparation                      │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.prepare_targets]
description = "Ensure all specified targets are installed via rustup"
category = "Build"
dependencies = ["init"]
script = '''
#!@duckscript

targets = get_env TARGETS
target_list = split ${targets} " "

echo "Preparing targets: ${targets}"

# Get installed targets
output = exec --get-exit-code rustup target list --installed
if not equals ${output.code} 0
    trigger_error "Failed to get installed targets"
end

installed = set ${output.stdout}

for target in ${target_list}
    target = trim ${target}
    if not is_empty ${target}
        if not contains ${installed} ${target}
            echo "Installing target: ${target}"
            exec --fail-on-error rustup target add ${target}
        else
            echo "Target already installed: ${target}"
        end
    end
end
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │                    Core Build Tasks                      │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.clean]
description = "Clean build artifacts"
category = "Build"
command = "cargo"
args = ["clean"]

[tasks.doc]
description = "Generate documentation"
category = "Documentation"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
exec --fail-on-error cargo doc ${feature_args} --no-deps
'''

[tasks.run]
description = "Run the binary (single-crate convenience)"
category = "Development"
dependencies = ["init"]
condition = { files_exist = ["src/main.rs"] }
script = '''
#!@duckscript
cargo_args = get_env CARGO_BUILD_ARGS
feature_args = get_env FEATURE_ARGS
exec --fail-on-error cargo run ${cargo_args} ${feature_args}
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │                  Target Matrix Tasks                     │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.build_targets]
description = "Build for all specified targets"
category = "Build"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

targets = get_env TARGETS
target_list = split ${targets} " "
cargo_args = get_env CARGO_BUILD_ARGS
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT

for target in ${target_list}
    target = trim ${target}
    if not is_empty ${target}
        echo "Building for target: ${target}"
        exec --fail-on-error cargo build --target ${target} ${cargo_args} ${feature_args} ${message_format}
    end
end
'''

[tasks.check_targets]
description = "Run cargo check for all specified targets"
category = "Build"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

targets = get_env TARGETS
target_list = split ${targets} " "
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT

for target in ${target_list}
    target = trim ${target}
    if not is_empty ${target}
        echo "Checking target: ${target}"
        exec --fail-on-error cargo check --target ${target} ${feature_args} ${message_format}
    end
end
'''

[tasks.clippy_targets]
description = "Run clippy for all specified targets"
category = "Build"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

targets = get_env TARGETS
target_list = split ${targets} " "
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
clippy_args = get_env CLIPPY_ARGS
all_targets = get_env ALL_TARGETS

for target in ${target_list}
    target = trim ${target}
    if not is_empty ${target}
        echo "Running clippy for target: ${target}"
        exec --fail-on-error cargo clippy --target ${target} ${feature_args} ${all_targets} ${message_format} -- ${clippy_args}
    end
end
'''

[tasks.test_targets]
description = "Run tests for all specified targets (skips if no runner available)"
category = "Test"
dependencies = ["init", "prepare_targets"]
script = '''
#!@duckscript

targets = get_env TARGETS
target_list = split ${targets} " "
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
host_triple = get_env HOST_TRIPLE

for target in ${target_list}
    target = trim ${target}
    if not is_empty ${target}
        # Check if we need a runner for cross-compilation
        needs_runner = not equals ${target} ${host_triple}
        
        if ${needs_runner}
            # Check if runner is configured
            runner_env = concat "CARGO_TARGET_" ${target}
            runner_env = replace ${runner_env} "-" "_"
            runner_env = to_uppercase ${runner_env}
            runner_env = concat ${runner_env} "_RUNNER"
            
            runner = get_env ${runner_env}
            if is_empty ${runner}
                echo "Skipping tests for ${target}: no runner configured (set ${runner_env})"
            else
                echo "Testing target ${target} with runner: ${runner}"
                exec --fail-on-error cargo test --target ${target} ${feature_args} ${message_format}
            end
        else
            echo "Testing target: ${target}"
            exec --fail-on-error cargo test --target ${target} ${feature_args} ${message_format}
        end
    end
end
'''

[tasks.package_targets]
description = "Package binaries for all targets into dist/<triple>/"
category = "Build"
dependencies = ["init", "build_targets"]
condition = { files_exist = ["src/main.rs"] }
script = '''
#!@duckscript

targets = get_env TARGETS
target_list = split ${targets} " "
dist_dir = get_env DIST_DIR
exe_suffix = get_env EXE_SUFFIX

# Get crate name and version from cargo
output = exec --get-exit-code cargo metadata --no-deps --format-version 1
if not equals ${output.code} 0
    trigger_error "Failed to get cargo metadata"
end

# Parse JSON manually (basic parsing)
json = set ${output.stdout}
crate_name = ""
crate_version = ""

# The cargo metadata JSON structure has packages array
# We need to extract the first package's name and version
# Look for "packages":[{ pattern to find the packages array
if contains ${json} "\"packages\":"
    # Split on "packages":[ to get the part after
    parts = split ${json} "\"packages\":["
    if greater_than ${parts.length} 1
        packages_part = array_get ${parts} 1
        
        # Now extract the first package object
        # Look for the first occurrence of "name": within the packages array
        if contains ${packages_part} "\"name\":"
            parts = split ${packages_part} "\"name\":"
            part = array_get ${parts} 1
            parts = split ${part} "\""
            crate_name = array_get ${parts} 1
        end
        
        # Look for the first occurrence of "version": within the packages array
        # This will be the package version, not the metadata format version
        if contains ${packages_part} "\"version\":"
            parts = split ${packages_part} "\"version\":"
            part = array_get ${parts} 1
            parts = split ${part} "\""
            crate_version = array_get ${parts} 1
        end
    end
end

if is_empty ${crate_name}
    trigger_error "Failed to determine crate name from cargo metadata"
end

if is_empty ${crate_version}
    trigger_error "Failed to determine crate version from cargo metadata"
end

echo "Packaging ${crate_name} v${crate_version}"

# Get binary name from Cargo.toml if different
binary_names_str = ""
cargo_content = readfile Cargo.toml
if contains ${cargo_content} "[[bin]]"
    # Extract all binary names from [[bin]] sections
    lines = split ${cargo_content} \n
    # Use empty string as false, non-empty as true to avoid truthy string bug
    in_bin = ""
    for line in ${lines}
        t = trim ${line}
        if starts_with ${t} "[[bin]]"
            in_bin = "1"
        elif starts_with ${t} "[["
            # Reset in_bin when encountering any other section
            in_bin = ""
        elif starts_with ${t} "["
            # Reset in_bin when encountering any section
            in_bin = ""
        elif not is_empty ${in_bin}
            # Check for exact "name = " pattern to avoid matching namespace, etc.
            if starts_with ${t} "name = "
                parts = split ${t} "\""
                if greater_than ${parts.length} 1
                    bin_name = array_get ${parts} 1
                    if not is_empty ${bin_name}
                        binary_names_str = concat ${binary_names_str} " " ${bin_name}
                    end
                end
            end
        end
    end
end

# Default to crate name if no [[bin]] names found
if is_empty ${binary_names_str}
    binary_names_str = ${crate_name}
end

# Prepare list of binaries to package
binary_names_str = trim ${binary_names_str}
bin_list = split ${binary_names_str} " "

for target in ${target_list}
    target = trim ${target}
    if not is_empty ${target}
        # Determine target directory
        target_dir = concat "target/" ${target}
        release = get_env RELEASE
        if equals ${release} "1"
            target_dir = concat ${target_dir} "/release"
        else
            target_dir = concat ${target_dir} "/debug"
        end
        
        # Package each binary
        for binary_name in ${bin_list}
            binary_name = trim ${binary_name}
            if not is_empty ${binary_name}
                # Source binary path
                src_binary = concat ${target_dir} "/" ${binary_name}
            
                # Handle Windows suffix
                if contains ${target} "windows"
                    if not ends_with ${src_binary} ".exe"
                        src_binary = concat ${src_binary} ".exe"
                    end
                end
                
                # Check if binary exists
                if is_path_exists ${src_binary}
                    # Create distribution directory
                    dist_target_dir = concat ${dist_dir} "/" ${target}
                    mkdir ${dist_target_dir}
                    
                    # Destination filename includes binary name to avoid collisions
                    dest_name = concat ${binary_name} "-" ${crate_version} "-" ${target}
                    if contains ${target} "windows"
                        dest_name = concat ${dest_name} ".exe"
                    end
                    
                    dest_path = concat ${dist_target_dir} "/" ${dest_name}
                    
                    echo "Copying ${src_binary} -> ${dest_path}"
                    cp ${src_binary} ${dest_path}
                else
                    echo "Warning: Binary not found at ${src_binary}"
                end
            end
        end
    end
end
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │                  Single-Crate Tasks                      │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.build]
description = "Build for host target"
category = "Build"
dependencies = ["init"]
script = '''
#!@duckscript
cargo_args = get_env CARGO_BUILD_ARGS
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo build ${cargo_args} ${feature_args} ${message_format}
'''

[tasks.test]
description = "Run tests for host target"
category = "Test"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo test ${feature_args} ${message_format}
'''

[tasks.check]
description = "Run cargo check for host target"
category = "Build"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo check ${feature_args} ${message_format}
'''

[tasks.clippy]
description = "Run clippy for host target"
category = "Build"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
clippy_args = get_env CLIPPY_ARGS
all_targets = get_env ALL_TARGETS
exec --fail-on-error cargo clippy ${feature_args} ${all_targets} ${message_format} -- ${clippy_args}
'''

[tasks.format]
description = "Check code formatting"
category = "Development"
command = "cargo"
args = ["fmt", "--", "--check"]

[tasks.format_fix]
description = "Fix code formatting"
category = "Development"
command = "cargo"
args = ["fmt"]

[tasks.fix]
description = "Run cargo fix"
category = "Development"
dependencies = ["init"]
script = '''
#!@duckscript
feature_args = get_env FEATURE_ARGS
message_format = get_env MESSAGE_FORMAT
exec --fail-on-error cargo fix ${feature_args} ${message_format} --allow-dirty
'''

#  ╭──────────────────────────────────────────────────────────╮
#  │                  Validation Sequences                    │
#  ╰──────────────────────────────────────────────────────────╯

[tasks.validate]
description = "Run validation sequence: format, build, test, clippy"
category = "CI"
dependencies = ["format", "build", "test", "clippy"]

[tasks.validate_targets]
description = "Run validation for all targets: format, build, test, clippy"
category = "CI"
dependencies = ["format", "build_targets", "test_targets", "clippy_targets"]

[tasks.validate_strict]
description = "Run validation with strict clippy settings"
category = "CI"
env = { "STRICT" = "1" }
dependencies = ["format", "build", "test", "clippy"]

[tasks.package_targets]
description = "Package built binary targets into dist/ with correct crate name and version"
script = [
'''
#!@duckscript

# Ensure jq is available
jq_exists = exec_output bash -c "command -v jq >/dev/null 2>&1; echo $?"
assert_eq ${jq_exists.stdout} "0" "jq is required but not found. Please install jq."

# Determine root Cargo.toml path
locate = exec_output cargo locate-project --message-format plain
assert ${locate.exit_code} "Failed to locate Cargo.toml"
root_manifest = trim ${locate.stdout}

# Fetch cargo metadata for the current project
meta = exec_output cargo metadata --format-version 1 --no-deps --manifest-path ${root_manifest}
assert ${meta.exit_code} "Failed to retrieve cargo metadata"
meta_json = set ${meta.stdout}

# Write metadata to a temporary file for jq processing
tmpfile = tempfile
writefile ${tmpfile} ${meta_json}

# Extract crate name and version for the current manifest path
name_out = exec_output bash -c "jq -r --arg mp '${root_manifest}' '.packages[] | select(.manifest_path == $mp) | .name' ${tmpfile}"
assert ${name_out.exit_code} "Failed to parse crate name from cargo metadata"
crate_name = trim ${name_out.stdout}

ver_out = exec_output bash -c "jq -r --arg mp '${root_manifest}' '.packages[] | select(.manifest_path == $mp) | .version' ${tmpfile}"
assert ${ver_out.exit_code} "Failed to parse crate version from cargo metadata"
crate_version = trim ${ver_out.stdout}

# Get list of binary targets for the current crate
bins_out = exec_output bash -c "jq -r --arg mp '${root_manifest}' '.packages[] | select(.manifest_path == $mp) | .targets[] | select(.kind[] == \"bin\") | .name' ${tmpfile}"
assert ${bins_out.exit_code} "Failed to parse binary targets from cargo metadata"

# Prepare dist directory
dist_dir = set dist
mkdir ${dist_dir}

# Package each binary target from target/release
bins = split ${bins_out.stdout} "\n"
for bin_name in ${bins}
    skip = is_empty ${bin_name}
    if not ${skip}
        src_path = set target/release/${bin_name}
        exists = is_file ${src_path}
        if ${exists}
            # If multiple binaries, include bin name in artifact; if single, still include for consistency
            artifact = set ${dist_dir}/${crate_name}-v${crate_version}-${bin_name}
            cp ${src_path} ${artifact}
            chmod +x ${artifact}
            echo Packaged ${artifact}
        else
            echo Warning: built binary not found at ${src_path}. Did you run a release build?
        end
    end
end

# Clean up
rm ${tmpfile}
'''
]


